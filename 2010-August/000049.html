<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [gpt-devel] Vamos dar prosseguimento a V2 ???
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gpt-devel/2010-August/index.html" >
   <LINK REL="made" HREF="mailto:gpt-devel%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-devel%5D%20Vamos%20dar%20prosseguimento%20a%20V2%20%3F%3F%3F&In-Reply-To=%3CAANLkTimVzz_Oy%3DipuEQWbqbLpwCiVTALNcNRe%2B%3DwwGhu%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000047.html">
   <LINK REL="Next"  HREF="000050.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[gpt-devel] Vamos dar prosseguimento a V2 ???</H1>
    <B>Alex Garzao</B> 
    <A HREF="mailto:gpt-devel%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-devel%5D%20Vamos%20dar%20prosseguimento%20a%20V2%20%3F%3F%3F&In-Reply-To=%3CAANLkTimVzz_Oy%3DipuEQWbqbLpwCiVTALNcNRe%2B%3DwwGhu%40mail.gmail.com%3E"
       TITLE="[gpt-devel] Vamos dar prosseguimento a V2 ???">alexgarzaol at gmail.com
       </A><BR>
    <I>Thu Aug  5 21:18:44 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000047.html">[gpt-devel] Vamos dar prosseguimento a V2 ???
</A></li>
        <LI>Next message: <A HREF="000050.html">[gpt-devel] Vamos dar prosseguimento a V2 ???
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49">[ date ]</a>
              <a href="thread.html#49">[ thread ]</a>
              <a href="subject.html#49">[ subject ]</a>
              <a href="author.html#49">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Oi,


&gt;<i> &gt; Boiei hehehe. O que seriam m&#243;dulos parametrizados??? Algo no estilo
</I>&gt;<i> &gt; &quot;programa&#231;&#227;o gen&#233;rica&quot;???
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> &#233;, algo no estilo...
</I>&gt;<i> <A HREF="http://lambda-the-ultimate.org/node/3735">http://lambda-the-ultimate.org/node/3735</A>
</I>&gt;<i> <A HREF="http://gbracha.blogspot.com/2009/06/ban-on-imports.html">http://gbracha.blogspot.com/2009/06/ban-on-imports.html</A>
</I>

Interessante :-)


&gt;<i> &gt;&gt; No que tange as ferramentas de compila&#231;&#227;o/transforma&#231;&#227;o e a m&#225;quina
</I>&gt;<i> &gt;&gt; virtual, eu acho muito interessante considerar a portabilidade entre
</I>&gt;<i> &gt;&gt; diversas vms. E certamente, de podermos trabalhar nossos pr&#243;prios
</I>&gt;<i> &gt;&gt; runtimes :)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Ent&#227;o acredito que uma linguagem intermedi&#225;ria (tipo GptAssembly ou
</I>&gt;<i> similar)
</I>&gt;<i> &gt; facilitaria esta tarefa certo ?
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> sim, eu ainda acho importante termos gptassembly
</I>&gt;<i>
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; OMeta: an Object-Oriented Language for Pattern Matching
</I>&gt;<i> &gt;&gt; <A HREF="http://www.tinlizzie.org/~awarth/papers/dls07.pdf">http://www.tinlizzie.org/~awarth/papers/dls07.pdf</A>
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Escrevi em 2008 um paper utilizando uma implementa&#231;&#227;o dessa
</I>&gt;<i> &gt;&gt; (meta)linguagem, e achei um brinquedinho fascinante para realizar
</I>&gt;<i> &gt;&gt; transforma&#231;&#245;es. Mas como &#233; uma linguagem baseada em PEGs e n&#227;o nas
</I>&gt;<i> &gt;&gt; famosas gram&#225;ticas livres de contexto, cabe refletir se vale te-la
</I>&gt;<i> &gt;&gt; como compilador nesse primeiro momento, dado que ninguem aprende PEGs
</I>&gt;<i> &gt;&gt; nas aulas de compiladores. Talvez seja melhor utilizar uma compila&#231;&#227;o
</I>&gt;<i> &gt;&gt; tradicional e, no futuro, ter uma gram&#225;tica equivalente em OMeta. De
</I>&gt;<i> &gt;&gt; qualquer forma, eu acho que ela pode ser utilizada bem em etapas de
</I>&gt;<i> &gt;&gt; otimiza&#231;&#227;o e demais transforma&#231;&#245;es de c&#243;digo.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Olhei superficialmente o artigo (+- 10 minutos) mas me pareceu bem
</I>&gt;<i> &gt; interessante. De qualquer forma, como voc&#234; mesmo disse, acho que deixamos
</I>&gt;<i> &gt; para um segundo momento. Mas gostei :-)
</I>&gt;<i> &gt;&gt;
</I>&gt;<i>
</I>&gt;<i> Se eu tivesse conseguido implementar na &#233;poca um bom mecanismo de
</I>&gt;<i> reportagem de erros no ometa, eu acho at&#233; que investiria em criar um
</I>&gt;<i> parser pro portugol inicialmente nessa linguagem e escrever uma GLR
</I>&gt;<i> pra algo como o antlr em um momento posterior. Mas parei no meio do
</I>&gt;<i> caminho e n&#227;o sei quando poderia retomar. Um plano B que pensei seria
</I>&gt;<i> usar o antlr para criar uma segunda meta-linguagem, baseada no antlr,
</I>&gt;<i> que extendesse a linguagem de gram&#225;tica para permitir especificar
</I>&gt;<i> mensagens de erros mais facilmente.
</I>&gt;<i>
</I>&gt;<i> Agora, considerando cronograma, acho que isso poderia ser secund&#225;rio.
</I>&gt;<i> Podemos ter um parser completo sem nos importarmos muito com mensagens
</I>&gt;<i> de erro em um primeiro momento.
</I>&gt;<i>
</I>
&#201; uma abordagem. N&#243;s estavamos utilizando AntLR vers&#227;o 2, mas lembro de ter
lido algo sobre a vers&#227;o 3 onde eles facilitam um pouco o report de erros.
Quando poss&#237;vel eu investigo melhor...


&gt;<i> &gt;&gt; The Virtual Processor: Fast, Architecture-Neutral Dynamic Code
</I>&gt;<i> Generation
</I>&gt;<i> &gt;&gt; (google encontra)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Tamb&#233;m achei bem interessante. Mas s&#243; olhando &quot;com calma&quot; para saber o
</I>&gt;<i> &gt; quanto nos seria &#250;til.
</I>&gt;<i> &gt; Eu posso estar enganado, mas na minha r&#225;pida leitura (15 minutos) eu
</I>&gt;<i> tenho a
</I>&gt;<i> &gt; impress&#227;o que o Virtual Processor abstrai gera&#231;&#227;o de c&#243;digo de m&#225;quina,
</I>&gt;<i> mas
</I>&gt;<i> &gt; de qualquer forma me parece ser muito &quot;baixo n&#237;vel&quot; perto do que a gente
</I>&gt;<i> &gt; precisa. E a gente continuaria tendo problemas para termos bibliotecas
</I>&gt;<i> &gt; port&#225;veis entre v&#225;rios sistemas operacionais (socket, thread, GUI, ...).
</I>&gt;<i>
</I>&gt;<i> &#233;, acho que ele tem um uso mais voltado pra JIT.... na pressa peguei
</I>&gt;<i> algo que n&#227;o representa bem a minha inten&#231;&#227;o... (embora seja uma id&#233;ia
</I>&gt;<i> para implementa&#231;&#245;es do que intenciono)
</I>&gt;<i>
</I>&gt;<i> o que eu queria provocar era uma discuss&#227;o sobre gera&#231;&#227;o de c&#243;digo
</I>&gt;<i> (n&#227;o necessariamente de m&#225;quina) em tempo de execu&#231;&#227;o, de forma a
</I>&gt;<i> permitir um processo de programa&#231;&#227;o mais explorat&#243;rio (al&#225; lisp,
</I>&gt;<i> smalltalk e outros ambientes din&#226;micos), ao inv&#233;s de restringir
</I>&gt;<i> somente ao ciclo compile-&gt;execute-&gt;kill-&gt;write. Isso tem um apelo
</I>&gt;<i> did&#225;tico muito grande e creio que trabalhar no gptassembly e runtime
</I>&gt;<i> com isso em mente seria importante.
</I>&gt;<i>
</I>
A id&#233;ia me parece interessante. De qualquer forma, eu n&#227;o tenho experi&#234;ncia
com isso, nem como &quot;usu&#225;rio&quot;. Voc&#234; poderia comentar o que poder&#237;amos fazer
de interessante com este recurso? Ali&#225;s, isso seria quase como eu definir
uma string (contendo um c&#243;digo v&#225;lido), &quot;compil&#225;-lo&quot; durante a execu&#231;&#227;o e
rod&#225;-lo como se fizesse parte do programa?


&gt;<i> De qualquer forma, concordo com o que disse sobre dependencias (foi
</I>&gt;<i> justamente o que me fez n&#227;o focar muito em traduzir c&#243;digo para outra
</I>&gt;<i> linguagem...n&#227;o queria exigir que as pessoas instalassem o gcc ou o
</I>&gt;<i> que for pra usar o gpt).
</I>&gt;<i>
</I>
Ok.

&gt;&gt;<i>
</I>&gt;<i> &gt;&gt; Em rela&#231;&#227;o &#224; linguagem gptassembly, eu gostaria de reve-la tbm para
</I>&gt;<i> &gt;&gt; saber at&#233; que ponto ela pode permitir que a gente pire aos poucos em
</I>&gt;<i> &gt;&gt; linguagens de alto nivel (late binding, restri&#231;&#227;o de tipos,
</I>&gt;<i> &gt;&gt; polimorfismo, etc..)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Isso &#233; verdade. Ela &#233; simples (at&#233; demais) e acho que para que a gente
</I>&gt;<i> possa
</I>&gt;<i> &gt; &quot;pirar&quot; com estes conceitos, ela teria que ser revista. Inclusive, talvez
</I>&gt;<i> &gt; seria interessante a gente avaliar a possibilidade de usar alguma
</I>&gt;<i> linguagem
</I>&gt;<i> &gt; intermedi&#225;ria j&#225; existente que tenha suporte a isso (IL deve ter,
</I>&gt;<i> &gt; certamente). Por&#233;m, n&#227;o ter&#237;amos o benef&#237;cio de uma linguagem
</I>&gt;<i> intermedi&#225;ria
</I>&gt;<i> &gt; em portugu&#234;s :-/
</I>&gt;<i>
</I>&gt;<i> hmm, verdade.
</I>&gt;<i>
</I>&gt;<i> &gt; Divagando um pouco, talvez seja o caso de continuarmos com a GptAssembly,
</I>&gt;<i> &gt; mas vendo como estes outros conceitos (late binding, restri&#231;&#227;o de tipos,
</I>&gt;<i> &gt; polimorfismo, ...) podem ser agregados nela.
</I>&gt;<i> &gt; Aproveitando. O que seria &quot;restri&#231;&#227;o de tipos&quot; ?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i>
</I>&gt;<i> legal. Restri&#231;&#227;o de tipos no sentido de type safety...
</I>

Ah ok.


&gt;<i> Bom, eu n&#227;o sei
</I>&gt;<i> tanto sobre isso a n&#237;vel de c&#243;digo de baixo n&#237;vel, mas acredito que
</I>&gt;<i> diversas VMs realizam checagem de tipos durante a execu&#231;&#227;o de forma a
</I>&gt;<i> impor seguran&#231;a.
</I>

Ah sim. JVM faz isso, DotNet tamb&#233;m, a parrot e a LuaVM tamb&#233;m. Das VMs que
eu me lembro agora, todas realizam checagem de tipos.


&gt;<i> Eu vou tentar ver com cuidado mais isso....acredito
</I>&gt;<i> que seria interessante ter o gptassembly sem &quot;tipos fortes&quot;.
</I>

Sinceramente, no momento, n&#227;o sei lhe dizer muito a respeito. O que sei
dizer &#233; que j&#225; implementei (academicamente) linguagens intermedi&#225;ria tipadas
e n&#227;o tipadas. No meu caso, essas linguagens intermedi&#225;rias representavam
&quot;um pra um&quot; as instru&#231;&#245;es das minhas VMs.

No geral, implementar VMs n&#227;o tipadas &#233; &quot;mais f&#225;cil&quot;, at&#233; porque o conjunto
de instru&#231;&#245;es fica BEM menor. Mas, de qualquer forma, a cada instru&#231;&#227;o a VM
tem que testar com que tipo est&#225; trabalhando (estou somando strings ou
n&#250;meros?). Se bem que as VMs tipadas tamb&#233;m validam os dados que est&#227;o
processando. Al&#233;m disso, no geral, VMs tipadas s&#227;o mais r&#225;pidas que n&#227;o
tipadas.

Talvez
&gt;<i> isso permita que tenhamos linguagem com tipagem forte e fraca em alto
</I>&gt;<i> n&#237;vel, sem termos grandes problemas em baixo n&#237;vel (at&#233; onde entendo,
</I>&gt;<i> ter tipagem forte no bytecode dificulta implementar gera&#231;&#227;o de c&#243;digo
</I>&gt;<i> de uma linguagem de alto n&#237;vel com tipagem fraca).
</I>&gt;<i>
</I>
Quanto a quest&#227;o de facilitar, n&#227;o sei dizer muito, mas pelo que eu saiba,
os compiladores de linguagens n&#227;o tipadas &quot;assumem&quot; um tipo conforme a
vari&#225;vel &#233; inicializada. Por exemplo &quot;x = 12&quot; assumem int e geram bytecode
indicando que x &#233; um int. Al&#233;m disso, caso x troque de tipo, internamente
estes compiladores criar outra vari&#225;vel conforme o novo tipo. Mas n&#227;o sou
nenhum especialista no assunto hehehe.

&gt;&gt;<i> O que me leva pensar sobre source level debugging. N&#227;o lembro se
</I>&gt;<i> &gt;&gt; chegamos a discutir isso, mas precisamos de informa&#231;&#245;es no objeto para
</I>&gt;<i> &gt;&gt; ajudar a depurar os programas..
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Tamb&#233;m n&#227;o lembro de termos conversado sobre isso. Inclusive, pensando
</I>&gt;<i> pouco
</I>&gt;<i> &gt; sobre o assunto, seria &quot;f&#225;cil&quot; fazer um debugger que atua sobre o c&#243;digo
</I>&gt;<i> &gt; intermedi&#225;rio, mas n&#227;o sobre o c&#243;digo final. Relembrando que, como a
</I>&gt;<i> id&#233;ia &#233;
</I>&gt;<i> &gt; podermos ter v&#225;rias sa&#237;das (bytecode, C, C++, assembly), como
</I>&gt;<i> instrumentar
</I>&gt;<i> &gt; todas estes &quot;formatos&quot; ? Acredito que at&#233; d&#225; (conforme o target)
</I>&gt;<i> &gt; instrument&#225;-lo, mas isso daria bastante trabalho porque seria uma forma
</I>&gt;<i> de
</I>&gt;<i> &gt; instrumenta&#231;&#227;o para cada target. J&#225; se instrumentarmos o c&#243;digo
</I>&gt;<i> &gt; intermedi&#225;rio, o debugger usaria estas informa&#231;&#245;es.
</I>&gt;<i> &gt; Mas adianto que n&#227;o sou muito entendido em debuggers, ent&#227;o posso ter
</I>&gt;<i> falado
</I>&gt;<i> &gt; besteira :-)
</I>&gt;<i>
</I>&gt;<i> &#201;, eu tbm n&#227;o sou nenhum entendido do assunto...Eu acho que seria
</I>&gt;<i> bastante importante termos debugger do pr&#243;prio gpt e da gptvm que
</I>&gt;<i> permitam depurar na linguagem de alto n&#237;vel. Eu sugeriria ignorarmos a
</I>&gt;<i> depura&#231;&#227;o em alto n&#237;vel para outros targets.
</I>&gt;<i>
</I>
&#201; uma abordagem. Com o tempo a gente v&#234; se d&#225; para estender para outros
targets. Enfim...

-- 
[]'s
Alex Sandro Garz&#227;o
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/gpt-devel/attachments/20100805/309b7dbb/attachment.html">https://lists.berlios.de/pipermail/gpt-devel/attachments/20100805/309b7dbb/attachment.html</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000047.html">[gpt-devel] Vamos dar prosseguimento a V2 ???
</A></li>
	<LI>Next message: <A HREF="000050.html">[gpt-devel] Vamos dar prosseguimento a V2 ???
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49">[ date ]</a>
              <a href="thread.html#49">[ thread ]</a>
              <a href="subject.html#49">[ subject ]</a>
              <a href="author.html#49">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gpt-devel">More information about the Gpt-devel
mailing list</a><br>
</body></html>
