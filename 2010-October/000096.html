<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [gpt-devel] Formato (gram&#225;tica) do GptAssembly
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gpt-devel/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:gpt-devel%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-devel%5D%0A%09%3D%3Fiso-8859-1%3Fq%3FFormato_%3D28gram%3DE1tica%3D29_do_GptAssemb%3F%3D%0A%09%3D%3Fiso-8859-1%3Fq%3Fly%3F%3D&In-Reply-To=%3CAANLkTin10ckX6Z9HE7yWcp%2BSq984obnL1eSzLbpwM_iC%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000095.html">
   <LINK REL="Next"  HREF="000097.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[gpt-devel] Formato (gram&#225;tica) do GptAssembly</H1>
    <B>Alex Garzao</B> 
    <A HREF="mailto:gpt-devel%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-devel%5D%0A%09%3D%3Fiso-8859-1%3Fq%3FFormato_%3D28gram%3DE1tica%3D29_do_GptAssemb%3F%3D%0A%09%3D%3Fiso-8859-1%3Fq%3Fly%3F%3D&In-Reply-To=%3CAANLkTin10ckX6Z9HE7yWcp%2BSq984obnL1eSzLbpwM_iC%40mail.gmail.com%3E"
       TITLE="[gpt-devel] Formato (gram&#225;tica) do GptAssembly">alexgarzaol at gmail.com
       </A><BR>
    <I>Fri Oct  8 16:29:25 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000095.html">[gpt-devel] Formato (gram&#225;tica) do GptAssembly
</A></li>
        <LI>Next message: <A HREF="000097.html">[gpt-devel] Formato (gram&#225;tica) do GptAssembly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#96">[ date ]</a>
              <a href="thread.html#96">[ thread ]</a>
              <a href="subject.html#96">[ subject ]</a>
              <a href="author.html#96">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>
</I>&gt;<i> &gt; De qq forma acho que a gente deveria avan&#231;ar um pouco mais as id&#233;ias
</I>&gt;<i> sobre o
</I>&gt;<i> &gt; GptAssembly. Eu &quot;acho&quot; que captei as suas id&#233;ias, mas gostaria (se
</I>&gt;<i> poss&#237;vel)
</I>&gt;<i> &gt; que voc&#234; implementasse os seguintes exemplos completos utilizando as duas
</I>&gt;<i> &gt; id&#233;ias:
</I>&gt;<i>
</I>&gt;<i> Ok. Para os exemplos abaixo, vou considerar o modelo de objetos
</I>&gt;<i> descrito em [1], onde:
</I>&gt;<i>
</I>
Bem interessante o artigo :-)


&gt;<i>  * N&#227;o existem classes.
</I>&gt;<i>  * Fun&#231;&#245;es podem ser vistas como objetos
</I>&gt;<i>  * cada objeto O &#233; uma tupla {Estado, Comportamento}
</I>&gt;<i>  * Estado &#233; um bloco de mem&#243;ria para armazenar os atributos
</I>&gt;<i>  * Comportamento (&quot;vtable&quot;) &#233; um objeto que possui, pelo menos, duas
</I>&gt;<i> informa&#231;&#245;es: um ponteiro para o objeto &quot;parent&quot;, e um dicion&#225;rio de
</I>&gt;<i> m&#233;todos.
</I>&gt;<i>  * Um ponteiro de objeto oop aponta para o primeiro atributo do
</I>&gt;<i> Estado. O endere&#231;o oop[-1] aponta para o objeto Comportamento.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; 1) Exemplo &quot;Ol&#225; mundo&quot;
</I>&gt;<i>
</I>&gt;<i> N&#227;o t&#227;o diferente...
</I>&gt;<i>
</I>&gt;<i> .m&#233;todo principal
</I>&gt;<i>      crstr &quot;Ol&#225; mundo!!!&quot; // Argumento 1
</I>&gt;<i>     crconst_1            // N&#250;mero de argumentos
</I>&gt;<i>     invocalib es.imprima
</I>&gt;<i>     sai_0
</I>&gt;<i> .fim_m&#233;todo
</I>&gt;<i>
</I>&gt;<i> Algumas sugest&#245;es sobre terminologia:
</I>&gt;<i> -Como fun&#231;&#245;es podem ser vistas como objetos autonomos, talvez a
</I>&gt;<i> nota&#231;&#227;o possa ser &quot;fun&#231;&#227;o&quot; ao inv&#233;s de &quot;m&#233;todo&quot;.
</I>&gt;<i>
</I>
Ok.

-Eu sugeriria que &quot;invocalib&quot; n&#227;o tivesse o &quot;lib&quot;. Quem sabe, algo
&gt;<i> gen&#233;rico como &quot;invoca&quot;, &quot;invoque&quot;, &quot;chame&quot;, &quot;envie&quot;, ou algo do tipo.
</I>&gt;<i>
</I>
Ok. Vou deixar invoca, mas podemos trocar depois.

Ent&#227;o o &quot;Ol&#225; mundo&quot; seria algo como:

.fun&#231;&#227;o principal
    carstr &quot;Ol&#225; mundo!!!&quot; // Argumento 1
    carconst_1            // N&#250;mero de argumentos
    invoca es.imprima
    sai_0
.fim_fun&#231;&#227;o



&gt;<i> &gt; 2) Como instanciar novos objetos e enviar mensagens (invocar seus
</I>&gt;<i> m&#233;todos)
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> -Enviando mensagens:
</I>&gt;<i>
</I>&gt;<i> Em termos de opcode, utilizando os cr*, etc e invocalib mesmo, da
</I>&gt;<i> forma como vc tem feito. Mas imagino que a sem&#226;ntica de invocalib
</I>&gt;<i> poderia ser de duas formas:
</I>&gt;<i>
</I>&gt;<i> a) Da forma descrita em [1], onde a VM chama o m&#233;todo &quot;lookup&quot; do
</I>&gt;<i> objeto vtable do receptor para obter o ponteiro do m&#233;todo. Dessa
</I>&gt;<i> forma, o lookup()  pode ser (re)programado no n&#237;vel acima da VM; ou
</I>&gt;<i>
</I>
Apesar de n&#227;o precisamos (hoje) no G-Portugol, esta possibilidade de
reprogramar um  m&#233;todo &#233; bem interessante :-)


&gt;<i> b) O lookup(m) &#233; feito pela pr&#243;pria VM, buscando por conta pr&#243;pria, no
</I>&gt;<i> dicion&#225;rio de m&#233;todos do objeto, o m&#233;todo &quot;m&quot;.
</I>&gt;<i>
</I>
Esta seria uma implementa&#231;&#227;o mais &quot;tradicional&quot; digamos assim.

A minha sugest&#227;o &#233; a seguinte. A nossa meta seria a abordagem a, onde os
m&#233;todos poderiam ser reimplementados. Por&#233;m, como eu sempre imagino
evoluirmos &quot;aos poucos&quot; o projeto, e, bem ou mal, isso n&#227;o faz diferen&#231;a
para o G-Portugol, a gente avalia o quanto mais de trabalho a abordagem a
vai gerar. Se for pouca coisa, j&#225; implementamos de cara. Se for dar bem mais
trabalho, a gente deixa para uma segunda etapa, at&#233; porque, se a gente
modelar bem a arquitetura, ser&#225; uma quest&#227;o de apenas &quot;plugar&quot; a nova
abordagem.

Antes que voc&#234; diga &quot;mais isto &#233; f&#225;cil&quot;. Bom, me parece ser f&#225;cil tamb&#233;m,
mas acho que devemos manter o m&#237;nimo de funcionalidade no in&#237;cio porque
sen&#227;o a gente surta com tanta coisa e acaba n&#227;o terminando nunca hehehe.
Como eu disse, avaliamos, e ser for muito tranq&#252;ilo, j&#225; implementamos de
cara, sen&#227;o fica para uma segunda etapa.


&gt;<i> Se &quot;m&quot; n&#227;o for encontrado pelo lookup(), ou a vm lan&#231;a uma excess&#227;o (o
</I>&gt;<i> que requer um mecanismo de exce&#231;&#245;es), ou a vm chama um m&#233;todo
</I>&gt;<i> espec&#237;fico (como em Smalltalk, onde a VM chama #doesNotUnderstand no
</I>&gt;<i> objeto receptor, que possui uma implementa&#231;&#227;o padr&#227;o definida na
</I>&gt;<i> classe Object).
</I>&gt;<i>
</I>
N&#227;o tenho muita experi&#234;ncia com isto, mas me parece que a segunda abordagem
&#233; mais tranq&#252;ila...


&gt;<i> -Criando objetos:
</I>&gt;<i>
</I>&gt;<i> No n&#237;vel mais primitivo, acho que precisariamos definir como alocar
</I>&gt;<i> mem&#243;ria e associar ao bloco de mem&#243;ria sua &quot;vtable&quot; -- algo que
</I>&gt;<i> represente seu Comportamento: hierarquia e dicion&#225;rio de m&#233;todos, por
</I>&gt;<i> exemplo. Talvez pudessemos ter um opcode (&quot;crie&quot;,&quot;aloca&quot;, ...) com um
</I>&gt;<i> argumento: n&#250;mero de bytes para alocar. A partir da&#237;, poderiamos fazer
</I>&gt;<i> a cria&#231;&#227;o de objetos mandando mensagens. As figuras 10 e 11 de [1]
</I>&gt;<i> apresentam uma poss&#237;vel implementa&#231;&#227;o.
</I>&gt;<i>
</I>
Antes de ler o artigo, eu achei estranho passar o n&#250;mero de bytes. Mas,
depois de uma boa leitura, ficou claro o motivo hehehe.

Por mim me parece ok esta abordagem.


&gt;<i> Neste caso, acho que entramos na conversa de como inicializar objetos.
</I>&gt;<i> Eu li algumas discuss&#245;es sobre este tema no passado mas n&#227;o lembro
</I>&gt;<i> muito agora. Talvez, no momento da cria&#231;&#227;o do objet, a VM poderia
</I>&gt;<i> chamar um m&#233;todo &quot;incialize&quot; tendo como receptor o novo objeto
</I>&gt;<i> alocado, caso esse m&#233;todo exista.
</I>&gt;<i>
</I>
Me parece ok. Talvez todos os objetos devam ter um inicialize (construtor)
definido. Ok, talvez o &quot;devam&quot; foi exagerado, mas me parece que simplifica
as coisas. Se bem que, testar se um m&#233;todo existe (ou n&#227;o) &#233; algo que deve
ser f&#225;cil para a VM...


&gt;<i> O que me leva a pensar que talvez seja necess&#225;rio pensar sobre como
</I>&gt;<i> implementar uma chamada equivalente a &quot;super()&quot;..
</I>&gt;<i>
</I>
No closure temos dados &quot;opacos&quot; e a implementa&#231;&#227;o do m&#233;todo. Acredito que na
se&#231;&#227;o de dados poderia ter um pointer (ou algo do g&#234;nero) que aponta para
o &quot;m&#233;todo pai&quot; (super).

Enfim, o exemplo para instanciar novos objetos e enviar mensagens seria algo
como:

.fun&#231;&#227;o imprime_oi // &#233; o m&#233;todo do nosso objeto
    carstr &quot;oi&quot;
    carconst_1
    invoca es.imprima
.fim_fun&#231;&#227;o

.fun&#231;&#227;o objeto_inic // &#233; o construtor do nosso objeto
    aloca XXX
    adicmetodo imprime_oi
    armres 0 // armazena o objeto como resultado de &#237;ndice 0 da fun&#231;&#227;o
.fim_fun&#231;&#227;o

.fun&#231;&#227;o principal // &#233; a fun&#231;&#227;o principal onde inicia a execu&#231;&#227;o das
aplica&#231;&#245;es
    .var obj
    buscafun&#231;&#227;o objeto_inic // busca/executa a fun&#231;&#227;o
    armobj obj // ok, como &#233; uma m&#225;quina de pilha, esta e a pr&#243;xima
instru&#231;&#227;o n&#227;o s&#227;o necess&#225;rias...
    carobj obj
    buscafun&#231;&#227;o imprime_oi
    sai_0
.fim_fun&#231;&#227;o

Quanto ao exemplo, eu acho que as defini&#231;&#245;es como &quot;.var obj&quot; v&#227;o continuar
existindo. Apesar de n&#227;o termos que explicitar o tipo (algo como .var objeto
obj) eu acho que estas defini&#231;&#245;es deixar&#227;o o nosso assembly mais
consistente. Apesar de n&#227;o ser necess&#225;rio definir o tipo, ser&#225; necess&#225;rio
informar quais as vari&#225;veis que ser&#227;o utilizadas.


&gt;<i> &gt; 3) Classe com um m&#233;todo sem argumentos e outro com argumentos, e como
</I>&gt;<i> estes
</I>&gt;<i> &gt; m&#233;todos s&#227;o invocados
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> Em termos de opcode, acho que eu faria da forma como vc tem feito,
</I>&gt;<i> empilhando os argumentos e o &quot;self&quot; e fazendo o send. A sem&#226;ntica da
</I>&gt;<i> chamada &#233; o que eu escrevi acima.
</I>&gt;<i>
</I>
O exemplo anterior exemplifica como seria com m&#233;todo sem argumentos.

Um exemplo com m&#233;todo com argumentos poderia ser:

.fun&#231;&#227;o imprime_msg // &#233; o m&#233;todo do nosso objeto
    .param msg
    carpar msg
    carconst_1
    invoca es.imprima
.fim_fun&#231;&#227;o

.fun&#231;&#227;o objeto_inic // &#233; o construtor do nosso objeto
    aloca XXX
    adicmetodo imprime_msg
    armres 0 // armazena o objeto como resultado de &#237;ndice 0 da fun&#231;&#227;o
.fim_fun&#231;&#227;o

.fun&#231;&#227;o principal // &#233; a fun&#231;&#227;o principal onde inicia a execu&#231;&#227;o das
aplica&#231;&#245;es
    .var obj
    buscafun&#231;&#227;o objeto_inic // busca/executa a fun&#231;&#227;o
    armobj obj // ok, como &#233; uma m&#225;quina de pilha, esta e a pr&#243;xima
instru&#231;&#227;o n&#227;o s&#227;o necess&#225;rias...
    carobj obj
    carstr &quot;Oi!!!&quot;
    buscafun&#231;&#227;o imprime_msg
    sai_0
.fim_fun&#231;&#227;o


&gt;<i> &gt; 4) Classe com m&#233;todo do tipo soma(x,y) que retorna a soma destes dois
</I>&gt;<i> &gt; valores
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> Aqui entra algo interessante. Se tivermos opcodes como &quot;add&quot; para
</I>&gt;<i> inteiros, acho que isso implica que temos, a n&#237;vel de VM, dois tipos
</I>&gt;<i> de valores: primitivos e objetos. Eu proponho que todas essas
</I>&gt;<i> opera&#231;&#245;es (que n&#227;o s&#227;o opera&#231;&#245;es sobre a pilha e a mem&#243;ria, por
</I>&gt;<i> exemplo) sejam feitas por envio de mensagens (e que todos os valores
</I>&gt;<i> sejam objetos), sem necessidade de implementar esses opcodes. Creio
</I>&gt;<i> que isso simplifica bastante a opera&#231;&#227;o da VM e elimina a dicotomia de
</I>&gt;<i> trabalhar com esses dois &quot;mundos&quot;. Esta abordagem &#233; descrita no Blue
</I>&gt;<i> Book do Smalltalk [2], no capitulo que descreve a m&#225;quina virtual.
</I>&gt;<i>
</I>
N&#227;o li este livro (fica para depois a leitura hehehe) mas eu concordo. Eu
prefiro que tudo seja objeto. Assim as coisas ficam mais claras, e qualquer
coisa pode ser reprogramada :-)


&gt;<i> Ent&#227;o, por exemplo, x+y poderia ser implementado carregando o
</I>&gt;<i> par&#226;metro &quot;y&quot;, o receptor &quot;x&quot; e invocando o m&#233;todo &quot;+&quot;. Claro que em
</I>&gt;<i> algum momento &quot;+&quot; deve ser definido. Em smalltalk-80, isso &#233; feito
</I>&gt;<i> tendo, para cada m&#233;todo compilado, um header possuindo uma flag
</I>&gt;<i> indicando se o m&#233;todo &#233; um &quot;m&#233;todo primitivo&quot;. Se for primitivo,
</I>&gt;<i> significa que n&#227;o h&#225; bytecode para este m&#233;todo, que ele &#233; implementado
</I>&gt;<i> pela pr&#243;pria VM. Isso permite que todas as primitivas da VM possam ser
</I>&gt;<i> sobrescritas a &quot;n&#237;vel de usu&#225;rio&quot;.
</I>&gt;<i>
</I>
Interessante. Seria algo como no artigo [1] onde a se&#231;&#227;o data de closure
pode conter um bytecode...

Um exemplo com soma(x,y) poderia ser algo como:

.fun&#231;&#227;o adiciona
     // implementado nativamente pela VM porque seria sobre tipos primitivos
.fim_fun&#231;&#227;o

.fun&#231;&#227;o soma // &#233; o m&#233;todo do nosso objeto
    .param x
    .param y
    carpar x
    carpar y
    buscafun&#231;&#227;o adiciona // adiciona seria implementado pela pr&#243;pria VM
    armres 0
.fim_fun&#231;&#227;o

.fun&#231;&#227;o objeto_inic // &#233; o construtor do nosso objeto
    aloca XXX
    adicmetodo adiciona
    armres 0 // armazena o objeto como resultado de &#237;ndice 0 da fun&#231;&#227;o
.fim_fun&#231;&#227;o

.fun&#231;&#227;o principal // &#233; a fun&#231;&#227;o principal onde inicia a execu&#231;&#227;o das
aplica&#231;&#245;es
    .var obj
    buscafun&#231;&#227;o objeto_inic // busca/executa a fun&#231;&#227;o
    armobj obj // ok, como &#233; uma m&#225;quina de pilha, esta e a pr&#243;xima
instru&#231;&#227;o n&#227;o s&#227;o necess&#225;rias...
    carobj obj
    carconst 10
    carconst 20
    buscafun&#231;&#227;o adiciona
    sai_0
.fim_fun&#231;&#227;o

Uma ressalva. Quanto a ordem em que os argumentos s&#227;o empilhados, talvez
seja necess&#225;rios empilharmos da direita para a esquerda, mas isso veremos
posteriormente.

N&#227;o sei se escrevi bem o que vc estava procurando, ent&#227;o, qualquer
&gt;<i> coisa, &#233; s&#243; falar :)
</I>&gt;<i>
</I>
Para mim esta troca de id&#233;ias e o artigo [1] foram essenciais para
continuarmos evoluindo hehehe. Valeu!!!!

Uma coisa. Olhando os exemplos agora, a sensa&#231;&#227;o que eu tive &#233; que, apesar
de estarmos simplificando a VM, os exemplos em GptAssembly est&#227;o ficando
&quot;complexos&quot;. Ok, algumas coisas ainda podem ser retiradas, mas mesmo assim
estou com a sensa&#231;&#227;o de que exemplos simples ficaram complexos. Imagina
termos que criar 5 classes, onde cada classe tem 10 m&#233;todos, 20
propriedades, ...

Bom, vamos evoluindo para ver onde chegamos :-)

Abra&#231;os!

-- 
[]'s
Alex Sandro Garz&#227;o
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/gpt-devel/attachments/20101008/3e391550/attachment.html">https://lists.berlios.de/pipermail/gpt-devel/attachments/20101008/3e391550/attachment.html</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000095.html">[gpt-devel] Formato (gram&#225;tica) do GptAssembly
</A></li>
	<LI>Next message: <A HREF="000097.html">[gpt-devel] Formato (gram&#225;tica) do GptAssembly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#96">[ date ]</a>
              <a href="thread.html#96">[ thread ]</a>
              <a href="subject.html#96">[ subject ]</a>
              <a href="author.html#96">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gpt-devel">More information about the Gpt-devel
mailing list</a><br>
</body></html>
