<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [gpt-devel] Formato (gram&#225;tica) do GptAssembly
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gpt-devel/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:gpt-devel%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-devel%5D%0A%09%3D%3Fiso-8859-1%3Fq%3FFormato_%3D28gram%3DE1tica%3D29_do_GptAssemb%3F%3D%0A%09%3D%3Fiso-8859-1%3Fq%3Fly%3F%3D&In-Reply-To=%3CAANLkTim9EcN-r9HVYuox0xWzFdw6W4YjfttLiNqGutcb%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000096.html">
   <LINK REL="Next"  HREF="000098.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[gpt-devel] Formato (gram&#225;tica) do GptAssembly</H1>
    <B>Thiago Silva</B> 
    <A HREF="mailto:gpt-devel%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-devel%5D%0A%09%3D%3Fiso-8859-1%3Fq%3FFormato_%3D28gram%3DE1tica%3D29_do_GptAssemb%3F%3D%0A%09%3D%3Fiso-8859-1%3Fq%3Fly%3F%3D&In-Reply-To=%3CAANLkTim9EcN-r9HVYuox0xWzFdw6W4YjfttLiNqGutcb%40mail.gmail.com%3E"
       TITLE="[gpt-devel] Formato (gram&#225;tica) do GptAssembly">tsilva at sourcecraft.info
       </A><BR>
    <I>Fri Oct  8 20:47:11 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000096.html">[gpt-devel] Formato (gram&#225;tica) do GptAssembly
</A></li>
        <LI>Next message: <A HREF="000098.html">[gpt-devel] Formato (gram&#225;tica) do GptAssembly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#97">[ date ]</a>
              <a href="thread.html#97">[ thread ]</a>
              <a href="subject.html#97">[ subject ]</a>
              <a href="author.html#97">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2010/10/8 Alex Garzao &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/gpt-devel">alexgarzaol at gmail.com</A>&gt;:
&gt;&gt;<i> -Eu sugeriria que &quot;invocalib&quot; n&#227;o tivesse o &quot;lib&quot;. Quem sabe, algo
</I>&gt;&gt;<i> gen&#233;rico como &quot;invoca&quot;, &quot;invoque&quot;, &quot;chame&quot;, &quot;envie&quot;, ou algo do tipo.
</I>&gt;<i>
</I>&gt;<i> Ok. Vou deixar invoca, mas podemos trocar depois.
</I>&gt;<i> Ent&#227;o o &quot;Ol&#225; mundo&quot; seria algo como:
</I>&gt;<i> .fun&#231;&#227;o principal
</I>&gt;<i>     carstr &quot;Ol&#225; mundo!!!&quot; // Argumento 1
</I>&gt;<i>     carconst_1            // N&#250;mero de argumentos
</I>&gt;<i>     invoca es.imprima
</I>&gt;<i>     sai_0
</I>&gt;<i> .fim_fun&#231;&#227;o
</I>&gt;<i>
</I>
Mais uma considera&#231;&#227;o: O que &#233; es.imprima? Ela ser&#225; uma string internalizada?

&gt;&gt;<i> a) Da forma descrita em [1], onde a VM chama o m&#233;todo &quot;lookup&quot; do
</I>&gt;&gt;<i> objeto vtable do receptor para obter o ponteiro do m&#233;todo. Dessa
</I>&gt;&gt;<i> forma, o lookup()  pode ser (re)programado no n&#237;vel acima da VM; ou
</I>&gt;<i>
</I>&gt;<i> Apesar de n&#227;o precisamos (hoje) no G-Portugol, esta possibilidade de
</I>&gt;<i> reprogramar um  m&#233;todo &#233; bem interessante :-)
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> b) O lookup(m) &#233; feito pela pr&#243;pria VM, buscando por conta pr&#243;pria, no
</I>&gt;&gt;<i> dicion&#225;rio de m&#233;todos do objeto, o m&#233;todo &quot;m&quot;.
</I>&gt;<i>
</I>&gt;<i> Esta seria uma implementa&#231;&#227;o mais &quot;tradicional&quot; digamos assim.
</I>&gt;<i> A minha sugest&#227;o &#233; a seguinte. A nossa meta seria a abordagem a, onde os
</I>&gt;<i> m&#233;todos poderiam ser reimplementados. Por&#233;m, como eu sempre imagino
</I>&gt;<i> evoluirmos &quot;aos poucos&quot; o projeto, e, bem ou mal, isso n&#227;o faz diferen&#231;a
</I>&gt;<i> para o G-Portugol, a gente avalia o quanto mais de trabalho a abordagem a
</I>&gt;<i> vai gerar. Se for pouca coisa, j&#225; implementamos de cara. Se for dar bem mais
</I>&gt;<i> trabalho, a gente deixa para uma segunda etapa, at&#233; porque, se a gente
</I>&gt;<i> modelar bem a arquitetura, ser&#225; uma quest&#227;o de apenas &quot;plugar&quot; a nova
</I>&gt;<i> abordagem.
</I>&gt;<i> Antes que voc&#234; diga &quot;mais isto &#233; f&#225;cil&quot;. Bom, me parece ser f&#225;cil tamb&#233;m,
</I>&gt;<i> mas acho que devemos manter o m&#237;nimo de funcionalidade no in&#237;cio porque
</I>&gt;<i> sen&#227;o a gente surta com tanta coisa e acaba n&#227;o terminando nunca hehehe.
</I>&gt;<i> Como eu disse, avaliamos, e ser for muito tranq&#252;ilo, j&#225; implementamos de
</I>&gt;<i> cara, sen&#227;o fica para uma segunda etapa.
</I>&gt;<i>
</I>
Admito que eu misturei um pouco as coisas, por estar brincando
pessoalmente com VMs, hehe. Esta parte do lookup() eu realmente acho
n&#227;o ser essencial. Podemos ir com a forma tradicional sem problemas.


&gt;&gt;<i>
</I>&gt;&gt;<i> Se &quot;m&quot; n&#227;o for encontrado pelo lookup(), ou a vm lan&#231;a uma excess&#227;o (o
</I>&gt;&gt;<i> que requer um mecanismo de exce&#231;&#245;es), ou a vm chama um m&#233;todo
</I>&gt;&gt;<i> espec&#237;fico (como em Smalltalk, onde a VM chama #doesNotUnderstand no
</I>&gt;&gt;<i> objeto receptor, que possui uma implementa&#231;&#227;o padr&#227;o definida na
</I>&gt;&gt;<i> classe Object).
</I>&gt;<i>
</I>&gt;<i> N&#227;o tenho muita experi&#234;ncia com isto, mas me parece que a segunda abordagem
</I>&gt;<i> &#233; mais tranq&#252;ila...
</I>&gt;<i>
</I>
tamb&#233;m acho...

&gt;&gt;<i>
</I>&gt;&gt;<i> -Criando objetos:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> No n&#237;vel mais primitivo, acho que precisariamos definir como alocar
</I>&gt;&gt;<i> mem&#243;ria e associar ao bloco de mem&#243;ria sua &quot;vtable&quot; -- algo que
</I>&gt;&gt;<i> represente seu Comportamento: hierarquia e dicion&#225;rio de m&#233;todos, por
</I>&gt;&gt;<i> exemplo. Talvez pudessemos ter um opcode (&quot;crie&quot;,&quot;aloca&quot;, ...) com um
</I>&gt;&gt;<i> argumento: n&#250;mero de bytes para alocar. A partir da&#237;, poderiamos fazer
</I>&gt;&gt;<i> a cria&#231;&#227;o de objetos mandando mensagens. As figuras 10 e 11 de [1]
</I>&gt;&gt;<i> apresentam uma poss&#237;vel implementa&#231;&#227;o.
</I>&gt;<i>
</I>&gt;<i> Antes de ler o artigo, eu achei estranho passar o n&#250;mero de bytes. Mas,
</I>&gt;<i> depois de uma boa leitura, ficou claro o motivo hehehe.
</I>&gt;<i> Por mim me parece ok esta abordagem.
</I>&gt;<i>
</I>
S&#243; um ponto, eu acho que talvez seja necess&#225;rio passar dois argumentos
para &quot;aloca/cria&quot;: o tamanho do estado do objeto em bytes e um
ponteiro para o objeto vtable. Assim, temos como retorno um objeto
completo, sem causar problemas por trabalhar com algo incompleto...


&gt;&gt;<i>
</I>&gt;&gt;<i> Neste caso, acho que entramos na conversa de como inicializar objetos.
</I>&gt;&gt;<i> Eu li algumas discuss&#245;es sobre este tema no passado mas n&#227;o lembro
</I>&gt;&gt;<i> muito agora. Talvez, no momento da cria&#231;&#227;o do objet, a VM poderia
</I>&gt;&gt;<i> chamar um m&#233;todo &quot;incialize&quot; tendo como receptor o novo objeto
</I>&gt;&gt;<i> alocado, caso esse m&#233;todo exista.
</I>&gt;<i>
</I>&gt;<i> Me parece ok. Talvez todos os objetos devam ter um inicialize (construtor)
</I>&gt;<i> definido. Ok, talvez o &quot;devam&quot; foi exagerado, mas me parece que simplifica
</I>&gt;<i> as coisas. Se bem que, testar se um m&#233;todo existe (ou n&#227;o) &#233; algo que deve
</I>&gt;<i> ser f&#225;cil para a VM...
</I>&gt;<i>
</I>
concordo.

&gt;&gt;<i>
</I>&gt;&gt;<i> O que me leva a pensar que talvez seja necess&#225;rio pensar sobre como
</I>&gt;&gt;<i> implementar uma chamada equivalente a &quot;super()&quot;..
</I>&gt;<i>
</I>&gt;<i> No closure temos dados &quot;opacos&quot; e a implementa&#231;&#227;o do m&#233;todo. Acredito que na
</I>&gt;<i> se&#231;&#227;o de dados poderia ter um pointer (ou algo do g&#234;nero) que aponta para
</I>&gt;<i> o &quot;m&#233;todo pai&quot; (super).
</I>
interessante. Eu n&#227;o tinha pensado nisso. Eu pensei em ter um outro
tipo de &quot;invoca&quot; que &quot;pula&quot; o dicion&#225;rio do objeto e come&#231;a a busca do
m&#233;todo no objeto pai.

&gt;<i> Enfim, o exemplo para instanciar novos objetos e enviar mensagens seria algo
</I>&gt;<i> como:
</I>&gt;<i> .fun&#231;&#227;o imprime_oi // &#233; o m&#233;todo do nosso objeto
</I>&gt;<i>     carstr &quot;oi&quot;
</I>&gt;<i>     carconst_1
</I>&gt;<i>     invoca es.imprima
</I>&gt;<i> .fim_fun&#231;&#227;o
</I>&gt;<i> .fun&#231;&#227;o objeto_inic // &#233; o construtor do nosso objeto
</I>&gt;<i>     aloca XXX
</I>&gt;<i>     adicmetodo imprime_oi
</I>&gt;<i>     armres 0 // armazena o objeto como resultado de &#237;ndice 0 da fun&#231;&#227;o
</I>&gt;<i> .fim_fun&#231;&#227;o
</I>&gt;<i> .fun&#231;&#227;o principal // &#233; a fun&#231;&#227;o principal onde inicia a execu&#231;&#227;o das
</I>&gt;<i> aplica&#231;&#245;es
</I>&gt;<i>     .var obj
</I>&gt;<i>     buscafun&#231;&#227;o objeto_inic // busca/executa a fun&#231;&#227;o
</I>&gt;<i>     armobj obj // ok, como &#233; uma m&#225;quina de pilha, esta e a pr&#243;xima
</I>&gt;<i> instru&#231;&#227;o n&#227;o s&#227;o necess&#225;rias...
</I>&gt;<i>     carobj obj
</I>&gt;<i>     buscafun&#231;&#227;o imprime_oi
</I>&gt;<i>     sai_0
</I>&gt;<i> .fim_fun&#231;&#227;o
</I>&gt;<i>
</I>
Acho que uma forma de simplificar a &quot;montagem&quot; de m&#233;todos no objeto
seria, ao inv&#233;s de adicionar os m&#233;todos do objeto via opcode (como em
objeto_inic), ter o arquivo bin&#225;rio especificando o mapeamento de
m&#233;todos e objetos. Assim, na leitura do bin&#225;rio, imagino que o loader
poderia ser respons&#225;vel por construir o objeto, adicionando os m&#233;todos
a ele e jogando-o no pool de objetos.

Ent&#227;o, digamos queremos definir um objeto X : Objeto() sem atributos,
com o m&#233;todo &quot;imprima_oi&quot;, uma sugest&#227;o seria:

-Ter, no arquivo bin&#225;rio:
  * Os bytecodes do m&#233;todo.
  * A associa&#231;&#227;o do m&#233;todo com seus nomes (&quot;imprime_oi&quot;)
  * a especifica&#231;&#227;o do objeto X (sem atributos, herda de Objeto)
  * A associa&#231;&#227;o do m&#233;todo ao objeto X

Ent&#227;o, poderiamos escrever:

.objeto X:Objeto

.m&#233;todo X:imprime_oi
    carstr &quot;oi&quot;
    carconst_1
    invoca es.imprima
.fim_fun&#231;&#227;o

.fun&#231;&#227;o principal // &#233; a fun&#231;&#227;o principal onde inicia a execu&#231;&#227;o das aplica&#231;&#245;es
    .var obj
    carobj X
    invoca novo //novo() &#233; definido em Objeto
    armobj obj // ok, como &#233; uma m&#225;quina de pilha, esta e a pr&#243;xima
instru&#231;&#227;o n&#227;o s&#227;o necess&#225;rias...
    carobj obj
    invoca imprime_oi
    sai_0
.fim_fun&#231;&#227;o

Podemos assumir que X faz parte do escopo l&#233;xico. Se assumirmos que
uma propriedade &quot;payload&quot; na vtable determina o tamanho de suas
inst&#226;ncias e que temos o objeto Objeto com as seguintes especifica&#231;&#245;es
de vtable e propriedades:

*Objeto (vtable: VTable)
-parent: null
-methods: {novo()}
-payload: 0 //inst&#226;ncias de Objeto n&#227;o possuem propriedades

.. e que a defini&#231;&#227;o &quot;X:Objeto&quot; cria o seguinte objeto:

*X (vtable: VTable)
-parent: Objeto
-methods: {imprime_oi()}
-payload: 0 //inst&#226;ncias de X n&#227;o possuemi propriedades

a implementa&#231;&#227;o de novo() poderia ser:

.m&#233;todo Objeto:novo
   //supondo que &quot;this&quot; est&#225; no topo da pilha e this = X
   carprop 2 //carrega o valor de payload de X: 0
   aloca       //cria um novo objeto [obj]
fim

Assim, X.novo() criaria uma nova inst&#226;ncia de X corretamente,
utlizando o m&#233;todo &quot;novo()&quot; herdado de Objeto. &quot;aloca&quot; cria um objeto
na mem&#243;ria com tamanho 0 (X.payload) e sua vtable apontar&#225; para X.

A sem&#226;ntica de &quot;invoca&quot; em &quot;invoca imprime_oi&quot; na forma mais
tradicional, ent&#227;o, faria o seguinte (tendo esta inst&#226;ncia &quot;obj&quot; no
topo):

* extrairia a vtable do receptor obj (que &#233; X)
* buscaria nos m&#233;todos de X o m&#233;todo &quot;imprime_oi&quot;
* Aplicaria este m&#233;todo ao &quot;obj&quot;


&gt;<i> Quanto ao exemplo, eu acho que as defini&#231;&#245;es como &quot;.var obj&quot; v&#227;o continuar
</I>&gt;<i> existindo. Apesar de n&#227;o termos que explicitar o tipo (algo como .var objeto
</I>&gt;<i> obj) eu acho que estas defini&#231;&#245;es deixar&#227;o o nosso assembly mais
</I>&gt;<i> consistente. Apesar de n&#227;o ser necess&#225;rio definir o tipo, ser&#225; necess&#225;rio
</I>&gt;<i> informar quais as vari&#225;veis que ser&#227;o utilizadas.
</I>&gt;<i>
</I>
Beleza. Antes, eu estava imaginando algo muito mais baixo n&#237;vel, como
especificar diretamente o espa&#231;o na pilha necess&#225;rio para as vari&#225;veis
locais, hehe.

&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; 3) Classe com um m&#233;todo sem argumentos e outro com argumentos, e como
</I>&gt;&gt;<i> &gt; estes
</I>&gt;&gt;<i> &gt; m&#233;todos s&#227;o invocados
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Em termos de opcode, acho que eu faria da forma como vc tem feito,
</I>&gt;&gt;<i> empilhando os argumentos e o &quot;self&quot; e fazendo o send. A sem&#226;ntica da
</I>&gt;&gt;<i> chamada &#233; o que eu escrevi acima.
</I>&gt;<i>
</I>&gt;<i> O exemplo anterior exemplifica como seria com m&#233;todo sem argumentos.
</I>&gt;<i> Um exemplo com m&#233;todo com argumentos poderia ser:
</I>&gt;<i> .fun&#231;&#227;o imprime_msg // &#233; o m&#233;todo do nosso objeto
</I>&gt;<i>     .param msg
</I>&gt;<i>     carpar msg
</I>&gt;<i>     carconst_1
</I>&gt;<i>     invoca es.imprima
</I>&gt;<i> .fim_fun&#231;&#227;o
</I>
beleza.

&gt;&gt;<i> &gt; 4) Classe com m&#233;todo do tipo soma(x,y) que retorna a soma destes dois
</I>&gt;&gt;<i> &gt; valores
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Aqui entra algo interessante. Se tivermos opcodes como &quot;add&quot; para
</I>&gt;&gt;<i> inteiros, acho que isso implica que temos, a n&#237;vel de VM, dois tipos
</I>&gt;&gt;<i> de valores: primitivos e objetos. Eu proponho que todas essas
</I>&gt;&gt;<i> opera&#231;&#245;es (que n&#227;o s&#227;o opera&#231;&#245;es sobre a pilha e a mem&#243;ria, por
</I>&gt;&gt;<i> exemplo) sejam feitas por envio de mensagens (e que todos os valores
</I>&gt;&gt;<i> sejam objetos), sem necessidade de implementar esses opcodes. Creio
</I>&gt;&gt;<i> que isso simplifica bastante a opera&#231;&#227;o da VM e elimina a dicotomia de
</I>&gt;&gt;<i> trabalhar com esses dois &quot;mundos&quot;. Esta abordagem &#233; descrita no Blue
</I>&gt;&gt;<i> Book do Smalltalk [2], no capitulo que descreve a m&#225;quina virtual.
</I>&gt;<i>
</I>&gt;<i> N&#227;o li este livro (fica para depois a leitura hehehe) mas eu concordo. Eu
</I>&gt;<i> prefiro que tudo seja objeto. Assim as coisas ficam mais claras, e qualquer
</I>&gt;<i> coisa pode ser reprogramada :-)
</I>&gt;<i>
</I>
j&#243;ia!

&gt;&gt;<i>
</I>&gt;&gt;<i> Ent&#227;o, por exemplo, x+y poderia ser implementado carregando o
</I>&gt;&gt;<i> par&#226;metro &quot;y&quot;, o receptor &quot;x&quot; e invocando o m&#233;todo &quot;+&quot;. Claro que em
</I>&gt;&gt;<i> algum momento &quot;+&quot; deve ser definido. Em smalltalk-80, isso &#233; feito
</I>&gt;&gt;<i> tendo, para cada m&#233;todo compilado, um header possuindo uma flag
</I>&gt;&gt;<i> indicando se o m&#233;todo &#233; um &quot;m&#233;todo primitivo&quot;. Se for primitivo,
</I>&gt;&gt;<i> significa que n&#227;o h&#225; bytecode para este m&#233;todo, que ele &#233; implementado
</I>&gt;&gt;<i> pela pr&#243;pria VM. Isso permite que todas as primitivas da VM possam ser
</I>&gt;&gt;<i> sobrescritas a &quot;n&#237;vel de usu&#225;rio&quot;.
</I>&gt;<i>
</I>&gt;<i> Interessante. Seria algo como no artigo [1] onde a se&#231;&#227;o data de closure
</I>&gt;<i> pode conter um bytecode...
</I>
Isso, a VM poderia escolher entre diferentes vers&#245;es de c&#243;digo para
executar, de acordo com algum crit&#233;rio.

&gt;<i> Um exemplo com soma(x,y) poderia ser algo como:
</I>&gt;<i> .fun&#231;&#227;o adiciona
</I>&gt;<i>      // implementado nativamente pela VM porque seria sobre tipos primitivos
</I>&gt;<i> .fim_fun&#231;&#227;o
</I>&gt;<i> .fun&#231;&#227;o soma // &#233; o m&#233;todo do nosso objeto
</I>&gt;<i>     .param x
</I>&gt;<i>     .param y
</I>&gt;<i>     carpar x
</I>&gt;<i>     carpar y
</I>&gt;<i>     buscafun&#231;&#227;o adiciona // adiciona seria implementado pela pr&#243;pria VM
</I>&gt;<i>     armres 0
</I>&gt;<i> .fim_fun&#231;&#227;o
</I>&gt;<i> .fun&#231;&#227;o objeto_inic // &#233; o construtor do nosso objeto
</I>&gt;<i>     aloca XXX
</I>&gt;<i>     adicmetodo adiciona
</I>&gt;<i>     armres 0 // armazena o objeto como resultado de &#237;ndice 0 da fun&#231;&#227;o
</I>&gt;<i> .fim_fun&#231;&#227;o
</I>&gt;<i> .fun&#231;&#227;o principal // &#233; a fun&#231;&#227;o principal onde inicia a execu&#231;&#227;o das
</I>&gt;<i> aplica&#231;&#245;es
</I>&gt;<i>     .var obj
</I>&gt;<i>     buscafun&#231;&#227;o objeto_inic // busca/executa a fun&#231;&#227;o
</I>&gt;<i>     armobj obj // ok, como &#233; uma m&#225;quina de pilha, esta e a pr&#243;xima
</I>&gt;<i> instru&#231;&#227;o n&#227;o s&#227;o necess&#225;rias...
</I>&gt;<i>     carobj obj
</I>&gt;<i>     carconst 10
</I>&gt;<i>     carconst 20
</I>&gt;<i>     buscafun&#231;&#227;o adiciona
</I>&gt;<i>     sai_0
</I>&gt;<i> .fim_fun&#231;&#227;o
</I>&gt;<i>
</I>
beleza

&gt;<i> Uma ressalva. Quanto a ordem em que os argumentos s&#227;o empilhados, talvez
</I>&gt;<i> seja necess&#225;rios empilharmos da direita para a esquerda, mas isso veremos
</I>&gt;<i> posteriormente.
</I>
beleza..

&gt;&gt;<i>
</I>&gt;&gt;<i> N&#227;o sei se escrevi bem o que vc estava procurando, ent&#227;o, qualquer
</I>&gt;&gt;<i> coisa, &#233; s&#243; falar :)
</I>&gt;<i>
</I>&gt;<i> Para mim esta troca de id&#233;ias e o artigo [1] foram essenciais para
</I>&gt;<i> continuarmos evoluindo hehehe. Valeu!!!!
</I>
Massa! :)

&gt;<i> Uma coisa. Olhando os exemplos agora, a sensa&#231;&#227;o que eu tive &#233; que, apesar
</I>&gt;<i> de estarmos simplificando a VM, os exemplos em GptAssembly est&#227;o ficando
</I>&gt;<i> &quot;complexos&quot;. Ok, algumas coisas ainda podem ser retiradas, mas mesmo assim
</I>&gt;<i> estou com a sensa&#231;&#227;o de que exemplos simples ficaram complexos. Imagina
</I>&gt;<i> termos que criar 5 classes, onde cada classe tem 10 m&#233;todos, 20
</I>&gt;<i> propriedades, ...
</I>
Ent&#227;o, eu imagino que vc se refira aos bytecodes tendo que &quot;construir&quot;
o objeto, adicionando seus m&#233;todos etc -- &#233; isso mesmo? Por isso que
eu sugeri que o bin&#225;rio j&#225; tivesse estas informa&#231;&#245;es para que o loader
criasse o objeto.

[]'s

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000096.html">[gpt-devel] Formato (gram&#225;tica) do GptAssembly
</A></li>
	<LI>Next message: <A HREF="000098.html">[gpt-devel] Formato (gram&#225;tica) do GptAssembly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#97">[ date ]</a>
              <a href="thread.html#97">[ thread ]</a>
              <a href="subject.html#97">[ subject ]</a>
              <a href="author.html#97">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gpt-devel">More information about the Gpt-devel
mailing list</a><br>
</body></html>
